import subprocess
import logging

logger = logging.getLogger(__name__)


class Command(object):
    """
    This object abstracts an execution of shell command. It uses the subprocess library to fork a system process
    and transfers stdout and stderr using subprocess.PIPE.

    Usage:
        -> cmd = Command('tuned-adm active')
        -> cmd.run()
        -> out, ret_code = cmd.get_output()
    """

    def __init__(self, cmdline, enable_debug_log=True):
        self._cmdline = cmdline.split()
        self._command_handle = None
        self.log_debug = logger.debug if enable_debug_log else lambda *_: None

    def __str__(self):
        return "{cls}: {cmd}".format(cls=self.__class__.__name__, cmd=self._cmd_str())

    def _cmd_str(self):
        return " ".join(self._cmdline)

    def run(self):
        self.log_debug("Running %s", self)
        self._command_handle = subprocess.Popen(
            self._cmdline, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        return self

    def wait(self):
        self.log_debug(f'Waiting to finish: {self}')
        self._command_handle.wait()
        return self

    def poll(self):
        return self._command_handle.poll()

    def _read_line_from_pipe(self):
        self._command_handle.stdout.flush()
        return self._command_handle.stdout.readline().decode()

    def _read_whole_pipe(self):
        self._command_handle.stdout.flush()
        return self._command_handle.stdout.read().decode()

    def get_output(self):
        self.wait()
        out = self._read_whole_pipe()
        ret_code = self.poll()
        self.log_debug(f"Command: {self}\nOutput: {out} Return code: {ret_code}")
        return out, ret_code

    def watch_output(self):
        """
        This method continuously logs an output generated by the executed command.
        :return: command output and return code
        """
        logger.info(f'Watching output of >> {self}')
        output_buffer = ''

        while self.poll() is None:
            line = self._read_line_from_pipe()
            self.log_debug(line.replace('\n', ''))
            output_buffer += line
        else:  # the end of the cycle
            line = self._read_whole_pipe()
            self.log_debug(line.replace('\n', ''))
            output_buffer += line

        return output_buffer, self.poll()

    def terminate(self):
        self._command_handle.terminate()


class ShellCommand(Command):
    """
    This class extends behaviour of Command class. It executes provided command inside unix shell environment, which
    is necessary for command with unix pipes or other shell utilities.
    """

    def __init__(self, cmdline, enable_debug_log=True):
        super().__init__(cmdline, enable_debug_log)
        self._cmdline = cmdline

    def _cmd_str(self):
        return self._cmdline

    def run(self):
        self.log_debug("Running command: %s", self._cmdline)
        self._command_handle = subprocess.Popen(
            self._cmdline, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)
        return self
