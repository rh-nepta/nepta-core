import subprocess
import logging

logger = logging.getLogger(__name__)


class Command(object):
    """
    This object abstracts an execution of shell command. It uses the subprocess library to fork a system process
    and transfers stdout and stderr using subprocess.PIPE.

    Usage:
        -> cmd = Command('tuned-adm active')
        -> cmd.run()
        -> out, ret_code = cmd.get_output()
    """

    def __init__(self, cmdline, enable_debug_log=True):
        self._cmdline = cmdline.split()
        self._command_handle = None
        self.log_debug = logger.debug if enable_debug_log else lambda *_: None

    def run(self):
        self.log_debug("Running command: %s", self._cmdline)
        self._command_handle = subprocess.Popen(
            self._cmdline, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    def wait(self):
        self.log_debug('Waiting for command to finish: %s' % self._cmdline)
        self._command_handle.wait()

    def poll(self):
        return self._command_handle.poll()

    def _read_line_from_pipe(self):
        self._command_handle.stdout.flush()
        return self._command_handle.stdout.readline().decode()

    def _read_whole_pipe(self):
        self._command_handle.stdout.flush()
        return self._command_handle.stdout.read().decode()

    def get_output(self):
        self.wait()
        out = self._read_whole_pipe()
        ret_code = self.poll()
        self.log_debug("Command: %s\nOutput: %sReturn code: %s", self._cmdline, out, ret_code)
        return out, ret_code

    def watch_output(self):
        """
        This method continuously logs an output generated by the executed command.
        :return: command output and return code
        """
        logger.info('Watching output of command: %s', self._cmdline)
        output_buffer = ''

        while self.poll() is None:
            line = self._read_line_from_pipe()
            self.log_debug(line.replace('\n', ''))
            output_buffer += line
        else:  # the end of the cycle
            line = self._read_whole_pipe()
            self.log_debug(line.replace('\n', ''))
            output_buffer += line

        return output_buffer, self.poll()

    def terminate(self):
        self._command_handle.terminate()
